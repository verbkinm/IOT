<h1>IOTV</h1>
<p>
    Система управления устройствами. Под устройствами (хостами) могут подразумеваться как автономные устройства на микроконтроллерах, так и отдельные программы на компьютерах.
    Протокол для общения хоста-сервера-клиента написан на Си, так что его легко можно использовать на любых микроконтроллерах.
</p>
<p>
    Проект состоит из трёх основных частей:
</p>

<h2>IOTV_Server</h2>
<ul>
    <li>Слушает выбранный tcp порт для связи с клиентами (файл настроек).</li>
    <li>Слушает tcp и udp порты для связи с tcp/udp хостами (файл настроек). Так же возможны другие типы подключений, такие как com-порт и текствый файл.</li>
    <li>Слушает broadcast для автоматического определения tcp/udp хостов в локальной сети (файл настроек).</li>
    <li>Считывает из файла ностроек данные по хостам, к которым необходимо подключиться (адрес, порт, тип подключения и пр.)</li>
</ul>

<h3>События:</h3>
<p>На сервере можно создавать события хостов следующего типа:</p>
<ul>
    <li>Подключения.</li>
    <li>Отключения.</li>
    <li>Состояние.</li>
    <li>Данные.</li>
    <li>Будильник.</li>
    <li>Таймер.</li>
</ul>

<h3>Действия:</h3>
<p>Для реагирования на события создаются действия следующих типов:</p>

<ul>
    <li><b>Data_tx</b> - отправка конкретных данных на конретное устройство.</li>
    <li><b>Data_tx_ref</b> - пересылка данных с одного устройства на другое.</li>
</ul>

<h2>IOTV_Host</h2>
<ul>
    <li><b>TCP, UDP</b> - вариант работы в режиме ожидания подключения сервера по tcp/udp порту.</li>
    <li><b>TCP_REVERSE, UDP_REVERSE</b> - указания хосту адреса сервера для подключения.</li>
    <li><b>Broadcast</b> - вариант broadcast рассылки для обнаружения сервером данного хоста и подключения к нему по tcp/udp порту.</li>
</ul>

<h2>IOTV_Client</h2>
<ul>
    <li>GUI приложение для связи с сервером. Получение данных о количестве устройств, их вид, получение/отправка данных на устройствства.</li>
    <li>Графический интерфейс разрабатывается с приоритетом использования приложения на мобильных устройствах. В первую очередь на Android смартфонах.</li>
</ul>

<hr>

<p>
Каждый хост имеет обязательные поля: 
<ul>
    <li>id устройства.</li>
    <li>имя устройства.</li>
    <li>описание устройства.</li>
</ul>
ID устройства необходимо для определение графического интерфейса на стороне клиента. Список устройств смотреть в файле <b>IOTV/docs/Список устройств.odt</b>
</p>

<p>
Каждый хост имеет два канала данных - <b>канал чтения</b> и <b>канал записи</b>. Каналы, в свою очередь, состоят из вектора блоков <b>(подканалов)</b>. Минимальное количество таких блоков - <b>0</b>, максимальное - <b>255</b>. Любой блок (подканал) должен быть одним из следующих типов:
    <ul>
        <li><b>INT_8</b> - целочисленный знаковый, 1 байт.</li>
        <li><b>INT_16</b> - целочисленный знаковый, 2 байта.</li>
        <li><b>INT_32</b> - целочисленный знаковый, 4 байта.</li>
        <li><b>INT_64</b> - целочисленный знаковый, 8 байт.</li>
        <li><b>FLOAT_32</b> - вещественный, 4 байта.</li>
        <li><b>DOUBLE_64</b> - вещественный, 8 байт. (на разных МК тип double может быть 32-битный)</li>
        <li><b>BOOL</b> - логический тип данных.</li>
        <li><b>STRING</b> - строка. Массив байт интерпретируемый как строка</li>
        <li><b>RAW</b> - Массив байт.</li>
        <li><b>NONE</b> - тип данных отсутствует.</li>
    </ul>
</p>

<h3>Примеры описывающие работу с каналами данных.</h3> 

<h3>Пример 1</h3> 

<p>Есть устройство с 3-я лампочками (реле или прочее оборудование, которое может быть в двух состояниях). На данном устройстве на канале чтения и канале записи имеется по 3 подканала. Каждый подканал имеет тип данных <b>BOOL</b>. Что бы считать данные о 1-й лампочке - необходимо получить данные с канала чтения 0-го подканала. Что бы считать данные о 2-й лампочке - необходимо получить данные с канала чтения 1-го подканала и т.д. Что бы включить 3-ю лампочку, необходимо в канал записи во 2-й подканал записать <b>true</b> или <b>1</b> и т.д:
</p>
<div style="width: 100%">
    <div style="display: table; margin: 0 auto;">
        <img src="readme_img/screen_1.png" width="400">
        <img src="readme_img/screen_2.png" width="400">
    </div>
</div>

<h3>Пример 2</h3> 
<p>Есть устройство с 3-я датчикам (температура, влажность, давление). На данном устройстве на канале чтения имеется 3 подканала, на канале записи - 0 подканалов. Каждый подканал имеет тип данных <b>FLOAT_32</b>. Что бы считать данные температуры - необходимо получить данные с канала чтения 0-го подканала. Что бы считать данные влажности - необходимо получить данные с канала чтения 1-го подканала. Что бы считать данные давления - необходимо получить данные с канала чтения 2-го подканала:
</p>
<div style="width: 100%">
    <div style="display: table; margin: 0 auto;">
        <img src="readme_img/screen_3.png" width="400">
        <img src="readme_img/screen_4.png" width="400">
    </div>
</div>

<h3>Пример 3</h3> 
<p>Большое количество подканалов и их разные типы можно использовать для создания более сложных решений. Как пример, онлайн камера:
</p>
<div style="width: 100%">
    <div style="display: table; margin: 0 auto;">
        <img src="readme_img/screen_5.png" width="400">
    </div>
</div>
